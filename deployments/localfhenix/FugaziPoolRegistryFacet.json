{
  "address": "0xD30C778F7Fd47CCfB93Caa589195eb288FC768c8",
  "abi": [
    {
      "inputs": [],
      "name": "BatchIsSettlement",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EpochNotEnded",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidShortString",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidTokenOrder",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OrderAlreadyClaimed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PoolAlreadyExists",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PoolNotFound",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SignerNotMessageSender",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SignerNotOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "str",
          "type": "string"
        }
      ],
      "name": "StringTooLong",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "noCorrespondingFacet",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "notOwner",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "Deposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "EIP712DomainChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "tokenX",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "tokenY",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        }
      ],
      "name": "PoolCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "Withdraw",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "epoch",
          "type": "uint32"
        }
      ],
      "name": "epochSettled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes4",
          "name": "selector",
          "type": "bytes4"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "facet",
          "type": "address"
        }
      ],
      "name": "facetAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "epoch",
          "type": "uint32"
        }
      ],
      "name": "orderSubmitted",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenX",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenY",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct inEuint32",
          "name": "_initialReserves",
          "type": "tuple"
        }
      ],
      "name": "createPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "eip712Domain",
      "outputs": [
        {
          "internalType": "bytes1",
          "name": "fields",
          "type": "bytes1"
        },
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "version",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "verifyingContract",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "uint256[]",
          "name": "extensions",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenX",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenY",
          "type": "address"
        }
      ],
      "name": "getPoolId",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x7c8ae434a88c8ab7e0a7057eec53297d4519b3845830932734824a2938a4a43b",
  "receipt": {
    "to": null,
    "from": "0xd7702EB6Ca4C101C918f7d4eaBeDc36e36260482",
    "contractAddress": "0xD30C778F7Fd47CCfB93Caa589195eb288FC768c8",
    "transactionIndex": 1,
    "gasUsed": "1705006",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xde7487baf28a6dac074607b4e878f556e6504c81f1ce7e0c3b75ae3055dce565",
    "transactionHash": "0x7c8ae434a88c8ab7e0a7057eec53297d4519b3845830932734824a2938a4a43b",
    "logs": [],
    "blockNumber": 15,
    "cumulativeGasUsed": "1705006",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "0c5385efa46cb58cf4f25a483a2e8f2f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BatchIsSettlement\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EpochNotEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderAlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignerNotMessageSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignerNotOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"noCorrespondingFacet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"notOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenX\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenY\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"}],\"name\":\"epochSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"facetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"}],\"name\":\"orderSubmitted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenY\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct inEuint32\",\"name\":\"_initialReserves\",\"type\":\"tuple\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenY\",\"type\":\"address\"}],\"name\":\"getPoolId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"EIP712DomainChanged()\":{\"details\":\"MAY be emitted to signal that the domain could have changed.\"}},\"kind\":\"dev\",\"methods\":{\"eip712Domain()\":{\"details\":\"See {IERC-5267}.\"}},\"version\":1},\"userdoc\":{\"errors\":{\"SignerNotMessageSender()\":[{\"notice\":\"Emitted when the signer is not the message sender\"}],\"SignerNotOwner()\":[{\"notice\":\"Emitted when the signer is not the specified owner\"}]},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/FugaziPoolRegistryFacet.sol\":\"FugaziPoolRegistryFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@fhenixprotocol/contracts/FHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n// solhint-disable one-contract-per-file\\n\\npragma solidity >=0.8.19 <=0.8.25;\\n\\nimport {Precompiles, FheOps} from \\\"./FheOS.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\ntype euint64 is uint256;\\ntype euint128 is uint256;\\ntype euint256 is uint256;\\ntype eaddress is uint256;\\n\\nstruct inEbool {\\n    bytes data;\\n}\\nstruct inEuint8 {\\n    bytes data;\\n}\\nstruct inEuint16 {\\n    bytes data;\\n}\\nstruct inEuint32 {\\n    bytes data;\\n}\\nstruct inEuint64 {\\n    bytes data;\\n}\\nstruct inEuint128 {\\n    bytes data;\\n}\\nstruct inEuint256 {\\n    bytes data;\\n}\\nstruct inEaddress {\\n    bytes data;\\n}\\n\\nstruct SealedArray {\\n  bytes[] data;\\n}\\n\\nlibrary Common {\\n    // Values used to communicate types to the runtime.\\n    // Must match values defined in warp-drive protobufs for everything to \\n    // make sense\\n    uint8 internal constant EUINT8_TFHE = 0;\\n    uint8 internal constant EUINT16_TFHE = 1;\\n    uint8 internal constant EUINT32_TFHE = 2;\\n    uint8 internal constant EUINT64_TFHE = 3;\\n    uint8 internal constant EUINT128_TFHE = 4;\\n    uint8 internal constant EUINT256_TFHE = 5;\\n    uint8 internal constant EADDRESS_TFHE = 12;\\n    // uint8 internal constant INT_BGV = 12;\\n    uint8 internal constant EBOOL_TFHE = 13;\\n    \\n    function bigIntToBool(uint256 i) internal pure returns (bool) {\\n        return (i > 0);\\n    }\\n\\n    function bigIntToUint8(uint256 i) internal pure returns (uint8) {\\n        return uint8(i);\\n    }\\n\\n    function bigIntToUint16(uint256 i) internal pure returns (uint16) {\\n        return uint16(i);\\n    }\\n\\n    function bigIntToUint32(uint256 i) internal pure returns (uint32) {\\n        return uint32(i);\\n    }\\n\\n    function bigIntToUint64(uint256 i) internal pure returns (uint64) {\\n        return uint64(i);\\n    }\\n\\n    function bigIntToUint128(uint256 i) internal pure returns (uint128) {\\n        return uint128(i);\\n    }\\n\\n    function bigIntToUint256(uint256 i) internal pure returns (uint256) {\\n        return i;\\n    }\\n\\n    function bigIntToAddress(uint256 i) internal pure returns (address) {\\n      return address(uint160(i));\\n    }\\n    \\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n    }\\n}\\n\\nlibrary Impl {\\n    function sealoutput(uint8 utype, uint256 ciphertext, bytes32 publicKey) internal pure returns (string memory reencrypted) {\\n        // Call the sealoutput precompile.\\n        reencrypted = FheOps(Precompiles.Fheos).sealOutput(utype, Common.toBytes(ciphertext), bytes.concat(publicKey));\\n\\n        return reencrypted;\\n    }\\n\\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the verify precompile.\\n        output = FheOps(Precompiles.Fheos).verify(_toType, _ciphertextBytes);\\n        result = getValue(output);\\n    }\\n\\n    function cast(uint8 utype, uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the cast precompile.\\n        output = FheOps(Precompiles.Fheos).cast(utype, Common.toBytes(ciphertext), toType);\\n        result = getValue(output);\\n    }\\n\\n    function getValue(bytes memory a) internal pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(a, 0x20))\\n        }\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the trivialEncrypt precompile.\\n        output = FheOps(Precompiles.Fheos).trivialEncrypt(Common.toBytes(value), toType);\\n\\n        result = getValue(output);\\n    }\\n\\n    function select(uint8 utype, uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the trivialEncrypt precompile.\\n        output = FheOps(Precompiles.Fheos).select(utype, Common.toBytes(control), Common.toBytes(ifTrue), Common.toBytes(ifFalse));\\n\\n        result = getValue(output);\\n    }\\n}\\n\\nlibrary FHE {\\n    euint8 public constant NIL8 = euint8.wrap(0);\\n    euint16 public constant NIL16 = euint16.wrap(0);\\n    euint32 public constant NIL32 = euint32.wrap(0);\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n    \\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n    \\n        // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n    \\n        // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    function getValue(bytes memory a) private pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(a, 0x20))\\n        }\\n    }\\n    \\n    function mathHelper(\\n        uint8 utype,\\n        uint256 lhs,\\n        uint256 rhs,\\n        function(uint8, bytes memory, bytes memory) external pure returns (bytes memory) impl\\n    ) internal pure returns (uint256 result) {\\n        bytes memory output;\\n        output = impl(utype, Common.toBytes(lhs), Common.toBytes(rhs));\\n        result = getValue(output);\\n    }\\n    \\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice performs the sealoutput function on a ebool ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(ebool value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEbool(0);\\n        }\\n        uint256 unwrapped = ebool.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EBOOL_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint8 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint8 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint8(0);\\n        }\\n        uint256 unwrapped = euint8.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT8_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint16 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint16 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint16(0);\\n        }\\n        uint256 unwrapped = euint16.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT16_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint32 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint32 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint32(0);\\n        }\\n        uint256 unwrapped = euint32.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT32_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint64 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint64 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint64(0);\\n        }\\n        uint256 unwrapped = euint64.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT64_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint128 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint128 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint128(0);\\n        }\\n        uint256 unwrapped = euint128.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT128_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint256 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint256 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint256(0);\\n        }\\n        uint256 unwrapped = euint256.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT256_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a eaddress ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(eaddress value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEaddress(0);\\n        }\\n        uint256 unwrapped = eaddress.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EADDRESS_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(ebool input1) internal pure returns (bool) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EBOOL_TFHE, inputAsBytes);\\n        return Common.bigIntToBool(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint8 input1) internal pure returns (uint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT8_TFHE, inputAsBytes);\\n        return Common.bigIntToUint8(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint16 input1) internal pure returns (uint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT16_TFHE, inputAsBytes);\\n        return Common.bigIntToUint16(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint32 input1) internal pure returns (uint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT32_TFHE, inputAsBytes);\\n        return Common.bigIntToUint32(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint64 input1) internal pure returns (uint64) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT64_TFHE, inputAsBytes);\\n        return Common.bigIntToUint64(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint128 input1) internal pure returns (uint128) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT128_TFHE, inputAsBytes);\\n        return Common.bigIntToUint128(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint256 input1) internal pure returns (uint256) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT256_TFHE, inputAsBytes);\\n        return Common.bigIntToUint256(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(eaddress input1) internal pure returns (address) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEaddress(0);\\n        }\\n        uint256 unwrappedInput1 = eaddress.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EADDRESS_TFHE, inputAsBytes);\\n        return Common.bigIntToAddress(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n\\n    function select(ebool input1, ebool input2, ebool input3) internal pure returns (ebool) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEbool(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEbool(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = ebool.unwrap(input2);\\n        uint256 unwrappedInput3 = ebool.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return ebool.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint8 input2, euint8 input3) internal pure returns (euint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint8(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint8(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint8.unwrap(input2);\\n        uint256 unwrappedInput3 = euint8.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint8.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint16 input2, euint16 input3) internal pure returns (euint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint16(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint16(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint16.unwrap(input2);\\n        uint256 unwrappedInput3 = euint16.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint16.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint32 input2, euint32 input3) internal pure returns (euint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint32(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint32(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint32.unwrap(input2);\\n        uint256 unwrappedInput3 = euint32.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint32.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint64 input2, euint64 input3) internal pure returns (euint64) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint64(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint64(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint64.unwrap(input2);\\n        uint256 unwrappedInput3 = euint64.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint64.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint128 input2, euint128 input3) internal pure returns (euint128) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint128(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint128(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint128.unwrap(input2);\\n        uint256 unwrappedInput3 = euint128.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint128.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint256 input2, euint256 input3) internal pure returns (euint256) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint256(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint256(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint256.unwrap(input2);\\n        uint256 unwrappedInput3 = euint256.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT256_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint256.wrap(result);\\n    }\\n\\n    function select(ebool input1, eaddress input2, eaddress input3) internal pure returns (eaddress) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEaddress(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEaddress(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = eaddress.unwrap(input2);\\n        uint256 unwrappedInput3 = eaddress.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EADDRESS_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return eaddress.wrap(result);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(ebool input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EBOOL_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint8 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT8_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint16 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT16_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint32 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT32_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint64 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT64_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint128 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT128_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint256 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT256_TFHE, inputAsBytes);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint256(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint256.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT256_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEaddress(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEaddress(0);\\n        }\\n        uint256 unwrappedInput1 = eaddress.unwrap(lhs);\\n        uint256 unwrappedInput2 = eaddress.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EADDRESS_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint256(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint256.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT256_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEaddress(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEaddress(0);\\n        }\\n        uint256 unwrappedInput1 = eaddress.unwrap(lhs);\\n        uint256 unwrappedInput2 = eaddress.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EADDRESS_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint128.wrap(result);\\n    }\\n\\n    /// @notice Performs the \\\"not\\\" for the ebool type\\n    /// @dev Implemented by a workaround due to ebool being a euint8 type behind the scenes, therefore xor is needed to assure that not(true) = false and vise-versa\\n    /// @param value input ebool ciphertext\\n    /// @return Result of the not operation on `value` \\n    function not(ebool value) internal pure returns (ebool) {\\n        return xor(value, asEbool(true));\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint8 input1) internal pure returns (euint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT8_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint16 input1) internal pure returns (euint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT16_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint32 input1) internal pure returns (euint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT32_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint64 input1) internal pure returns (euint64) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT64_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint128 input1) internal pure returns (euint128) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT128_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint128.wrap(result);\\n    }\\n\\n    // ********** TYPE CASTING ************* //\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEbool(inEbool memory value) internal pure returns (ebool) {\\n        return FHE.asEbool(value.data);\\n    }\\n    /// @notice Converts a ebool to an euint8\\n    function asEuint8(ebool value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint16\\n    function asEuint16(ebool value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint32\\n    function asEuint32(ebool value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint64\\n    function asEuint64(ebool value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint128\\n    function asEuint128(ebool value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint256\\n    function asEuint256(ebool value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a ebool to an eaddress\\n    function asEaddress(ebool value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint8 to an ebool\\n    function asEbool(euint8 value) internal pure returns (ebool) {\\n        return ne(value, asEuint8(0));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint8(inEuint8 memory value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value.data);\\n    }\\n    /// @notice Converts a euint8 to an euint16\\n    function asEuint16(euint8 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint32\\n    function asEuint32(euint8 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint64\\n    function asEuint64(euint8 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint128\\n    function asEuint128(euint8 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint256\\n    function asEuint256(euint8 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an eaddress\\n    function asEaddress(euint8 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint16 to an ebool\\n    function asEbool(euint16 value) internal pure returns (ebool) {\\n        return ne(value, asEuint16(0));\\n    }\\n    /// @notice Converts a euint16 to an euint8\\n    function asEuint8(euint16 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint16(inEuint16 memory value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value.data);\\n    }\\n    /// @notice Converts a euint16 to an euint32\\n    function asEuint32(euint16 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an euint64\\n    function asEuint64(euint16 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an euint128\\n    function asEuint128(euint16 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an euint256\\n    function asEuint256(euint16 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an eaddress\\n    function asEaddress(euint16 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint32 to an ebool\\n    function asEbool(euint32 value) internal pure returns (ebool) {\\n        return ne(value, asEuint32(0));\\n    }\\n    /// @notice Converts a euint32 to an euint8\\n    function asEuint8(euint32 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an euint16\\n    function asEuint16(euint32 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint32(inEuint32 memory value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value.data);\\n    }\\n    /// @notice Converts a euint32 to an euint64\\n    function asEuint64(euint32 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an euint128\\n    function asEuint128(euint32 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an euint256\\n    function asEuint256(euint32 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an eaddress\\n    function asEaddress(euint32 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint64 to an ebool\\n    function asEbool(euint64 value) internal pure returns (ebool) {\\n        return ne(value, asEuint64(0));\\n    }\\n    /// @notice Converts a euint64 to an euint8\\n    function asEuint8(euint64 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an euint16\\n    function asEuint16(euint64 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an euint32\\n    function asEuint32(euint64 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint64\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint64(inEuint64 memory value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value.data);\\n    }\\n    /// @notice Converts a euint64 to an euint128\\n    function asEuint128(euint64 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an euint256\\n    function asEuint256(euint64 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an eaddress\\n    function asEaddress(euint64 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint128 to an ebool\\n    function asEbool(euint128 value) internal pure returns (ebool) {\\n        return ne(value, asEuint128(0));\\n    }\\n    /// @notice Converts a euint128 to an euint8\\n    function asEuint8(euint128 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an euint16\\n    function asEuint16(euint128 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an euint32\\n    function asEuint32(euint128 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an euint64\\n    function asEuint64(euint128 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint128\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint128(inEuint128 memory value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value.data);\\n    }\\n    /// @notice Converts a euint128 to an euint256\\n    function asEuint256(euint128 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an eaddress\\n    function asEaddress(euint128 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint256 to an ebool\\n    function asEbool(euint256 value) internal pure returns (ebool) {\\n        return ne(value, asEuint256(0));\\n    }\\n    /// @notice Converts a euint256 to an euint8\\n    function asEuint8(euint256 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint16\\n    function asEuint16(euint256 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint32\\n    function asEuint32(euint256 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint64\\n    function asEuint64(euint256 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint128\\n    function asEuint128(euint256 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint256\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint256(inEuint256 memory value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value.data);\\n    }\\n    /// @notice Converts a euint256 to an eaddress\\n    function asEaddress(euint256 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a eaddress to an ebool\\n    function asEbool(eaddress value) internal pure returns (ebool) {\\n        return ne(value, asEaddress(0));\\n    }\\n    /// @notice Converts a eaddress to an euint8\\n    function asEuint8(eaddress value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint16\\n    function asEuint16(eaddress value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint32\\n    function asEuint32(eaddress value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint64\\n    function asEuint64(eaddress value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint128\\n    function asEuint128(eaddress value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint256\\n    function asEuint256(eaddress value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an eaddress\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEaddress(inEaddress memory value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value.data);\\n    }\\n    /// @notice Converts a uint256 to an ebool\\n    function asEbool(uint256 value) internal pure returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.EBOOL_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint8\\n    function asEuint8(uint256 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint16\\n    function asEuint16(uint256 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint32\\n    function asEuint32(uint256 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint64\\n    function asEuint64(uint256 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint128\\n    function asEuint128(uint256 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint256\\n    function asEuint256(uint256 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an eaddress\\n    function asEaddress(uint256 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(value, Common.EADDRESS_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEbool(bytes memory value) internal pure returns (ebool) {\\n        return ebool.wrap(Impl.verify(value, Common.EBOOL_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint8(bytes memory value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.verify(value, Common.EUINT8_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint16(bytes memory value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.verify(value, Common.EUINT16_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint32(bytes memory value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.verify(value, Common.EUINT32_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint64\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint64(bytes memory value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.verify(value, Common.EUINT64_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint128\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint128(bytes memory value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.verify(value, Common.EUINT128_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint256\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint256(bytes memory value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.verify(value, Common.EUINT256_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an eaddress\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEaddress(bytes memory value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(value, Common.EADDRESS_TFHE));\\n    }\\n    /// @notice Converts a address to an eaddress\\n    /// Allows for a better user experience when working with eaddresses\\n    function asEaddress(address value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint256(uint160(value)), Common.EADDRESS_TFHE));\\n    }\\n    /// @notice Converts a plaintext boolean value to a ciphertext ebool\\n    /// @dev Privacy: The input value is public, therefore the ciphertext should be considered public and should be used\\n    ///only for mathematical operations, not to represent data that should be private\\n    /// @return A ciphertext representation of the input \\n    function asEbool(bool value) internal pure returns (ebool) {\\n        uint256 sVal = 0;\\n        if (value) {\\n            sVal = 1;\\n        }\\n\\n        return asEbool(sVal);\\n    }\\n}\\n\\n// ********** OPERATOR OVERLOADING ************* //\\n\\nusing {operatorAddEuint8 as +} for euint8 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint16 as +} for euint16 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint32 as +} for euint32 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint64 as +} for euint64 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint128 as +} for euint128 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint8 as -} for euint8 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint16 as -} for euint16 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint32 as -} for euint32 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint64 as -} for euint64 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint128 as -} for euint128 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint8 as *} for euint8 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint16 as *} for euint16 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint32 as *} for euint32 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint64 as *} for euint64 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint8 as /} for euint8 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint16 as /} for euint16 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint32 as /} for euint32 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorOrEbool as |} for ebool global;\\n/// @notice Performs the or operation\\nfunction operatorOrEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint8 as |} for euint8 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint16 as |} for euint16 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint32 as |} for euint32 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint64 as |} for euint64 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint128 as |} for euint128 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorAndEbool as &} for ebool global;\\n/// @notice Performs the and operation\\nfunction operatorAndEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint8 as &} for euint8 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint16 as &} for euint16 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint32 as &} for euint32 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint64 as &} for euint64 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint128 as &} for euint128 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorXorEbool as ^} for ebool global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint8 as ^} for euint8 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint16 as ^} for euint16 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint32 as ^} for euint32 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint64 as ^} for euint64 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint128 as ^} for euint128 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint8 as %} for euint8 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint16 as %} for euint16 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint32 as %} for euint32 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\n// ********** BINDING DEFS ************* //\\n\\nusing BindingsEbool for ebool global;\\nlibrary BindingsEbool {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the eq\\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the ne\\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the and\\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the or\\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the xor\\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    function toU8(ebool value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(ebool value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(ebool value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(ebool value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(ebool value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(ebool value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(ebool value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(ebool value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(ebool value) internal pure returns (bool) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint8 for euint8 global;\\nlibrary BindingsEuint8 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the add\\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the mul\\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the div\\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the sub\\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the eq\\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the ne\\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the and\\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the or\\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the xor\\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the gt\\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the gte\\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the lt\\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the lte\\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the rem\\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the max\\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the min\\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the shl\\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the shr\\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint8 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU16(euint8 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint8 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint8 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint8 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint8 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint8 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint8 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint8 value) internal pure returns (uint8) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint16 for euint16 global;\\nlibrary BindingsEuint16 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the add\\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the mul\\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the div\\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the sub\\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the eq\\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the ne\\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the and\\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the or\\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the xor\\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the gt\\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the gte\\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the lt\\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the lte\\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the rem\\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the max\\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the min\\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the shl\\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the shr\\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint16 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint16 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU32(euint16 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint16 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint16 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint16 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint16 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint16 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint16 value) internal pure returns (uint16) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint32 for euint32 global;\\nlibrary BindingsEuint32 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the add\\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the mul\\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the div\\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the sub\\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the eq\\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the ne\\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the and\\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the or\\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the xor\\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the gt\\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the gte\\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the lt\\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the lte\\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the rem\\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the max\\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the min\\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the shl\\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the shr\\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint32 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint32 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint32 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU64(euint32 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint32 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint32 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint32 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint32 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint32 value) internal pure returns (uint32) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint64 for euint64 global;\\nlibrary BindingsEuint64 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the add\\n    function add(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the mul\\n    function mul(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the sub\\n    function sub(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the eq\\n    function eq(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the ne\\n    function ne(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the and\\n    function and(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the or\\n    function or(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the xor\\n    function xor(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the gt\\n    function gt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the gte\\n    function gte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the lt\\n    function lt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the lte\\n    function lte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the max\\n    function max(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the min\\n    function min(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the shl\\n    function shl(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the shr\\n    function shr(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint64 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint64 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint64 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint64 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU128(euint64 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint64 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint64 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint64 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint64 value) internal pure returns (uint64) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint128 for euint128 global;\\nlibrary BindingsEuint128 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the add\\n    function add(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the sub\\n    function sub(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the eq\\n    function eq(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the ne\\n    function ne(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the and\\n    function and(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the or\\n    function or(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the xor\\n    function xor(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the gt\\n    function gt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the gte\\n    function gte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the lt\\n    function lt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the lte\\n    function lte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the max\\n    function max(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the min\\n    function min(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the shl\\n    function shl(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the shr\\n    function shr(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint128 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint128 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint128 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint128 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint128 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU256(euint128 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint128 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint128 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint128 value) internal pure returns (uint128) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint256 for euint256 global;\\nlibrary BindingsEuint256 {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint256\\n    /// @return the result of the eq\\n    function eq(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint256\\n    /// @return the result of the ne\\n    function ne(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    function toBool(euint256 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint256 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint256 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint256 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint256 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint256 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toEaddress(euint256 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint256 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint256 value) internal pure returns (uint256) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEaddress for eaddress global;\\nlibrary BindingsEaddress {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type eaddress\\n    /// @return the result of the eq\\n    function eq(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type eaddress\\n    /// @return the result of the ne\\n    function ne(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    function toBool(eaddress value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(eaddress value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(eaddress value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(eaddress value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(eaddress value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(eaddress value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(eaddress value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function seal(eaddress value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(eaddress value) internal pure returns (address) {\\n        return FHE.decrypt(value);\\n    }\\n}\",\"keccak256\":\"0x1ffd2f9f5c64d58f600d54eba6c74d5c158455dd3e1eb827f1e745b1c81218a3\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhenixprotocol/contracts/FheOS.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n// solhint-disable one-contract-per-file\\npragma solidity >=0.8.13 <0.9.0;\\n\\nlibrary Precompiles {\\n    //solhint-disable const-name-snakecase\\n    address public constant Fheos = address(128);\\n}\\n\\ninterface FheOps {\\n    function log(string memory s) external pure;\\n    function add(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function verify(uint8 utype, bytes memory input) external pure returns (bytes memory);\\n    function sealOutput(uint8 utype, bytes memory ctHash, bytes memory pk) external pure returns (string memory);\\n    function decrypt(uint8 utype, bytes memory input) external pure returns (uint256);\\n    function lte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function sub(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function mul(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function lt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function select(uint8 utype, bytes memory controlHash, bytes memory ifTrueHash, bytes memory ifFalseHash) external pure returns (bytes memory);\\n    function req(uint8 utype, bytes memory input) external pure returns (bytes memory);\\n    function cast(uint8 utype, bytes memory input, uint8 toType) external pure returns (bytes memory);\\n    function trivialEncrypt(bytes memory input, uint8 toType) external pure returns (bytes memory);\\n    function div(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function gt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function gte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function rem(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function and(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function or(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function xor(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function eq(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function ne(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function min(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function max(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function shl(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function shr(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function not(uint8 utype, bytes memory value) external pure returns (bytes memory);\\n    function getNetworkPublicKey() external pure returns (bytes memory);\\n}\",\"keccak256\":\"0xc704013bec920b763d309d02f6c459acb16326b056bea878ee2130792be2fdac\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhenixprotocol/contracts/access/Permissioned.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity >=0.8.19 <0.8.25;\\n\\nimport { ECDSA } from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport { EIP712 } from \\\"@openzeppelin/contracts/utils/cryptography/EIP712.sol\\\";\\n\\n/// @title Permissioned Access Control Contract\\n/// @notice Abstract contract that provides EIP-712 based signature verification for access control\\n/// @dev This contract should be inherited by other contracts to provide EIP-712 signature validated access control\\nabstract contract Permissioned is EIP712 {\\n    /// @notice Emitted when the signer is not the message sender\\n    error SignerNotMessageSender();\\n\\n    /// @notice Emitted when the signer is not the specified owner\\n    error SignerNotOwner();\\n\\n    /// @dev Constructor that initializes EIP712 domain separator with a name and version\\n    /// solhint-disable-next-line func-visibility, no-empty-blocks\\n    constructor() EIP712(\\\"Fhenix Permission\\\", \\\"1.0\\\") {} \\n\\n    /// @notice Modifier that requires the provided signature to be signed by the message sender\\n    /// @param permission Data structure containing the public key and the signature to be verified\\n    modifier onlySender(Permission memory permission) {\\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n            keccak256(\\\"Permissioned(bytes32 publicKey)\\\"),\\n            permission.publicKey\\n        )));\\n        address signer = ECDSA.recover(digest, permission.signature);\\n        if (signer != msg.sender)\\n            revert SignerNotMessageSender();\\n        _;\\n    }\\n\\n    /// @notice Modifier that requires the provided signature to be signed by a specific owner address\\n    /// @param permission Data structure containing the public key and the signature to be verified\\n    /// @param owner The expected owner of the public key to match against the recovered signer\\n    modifier onlyPermitted(Permission memory permission, address owner) {\\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n            keccak256(\\\"Permissioned(bytes32 publicKey)\\\"),\\n            permission.publicKey\\n        )));\\n        address signer = ECDSA.recover(digest, permission.signature);\\n        if (signer != owner)\\n            revert SignerNotOwner();\\n        _;\\n    }\\n}\\n\\n/// @title Struct for holding signature information\\n/// @notice Used to pass both the public key and signature data within transactions\\n/// @dev Should be used with Signature-based modifiers for access control\\nstruct Permission {\\n    bytes32 publicKey;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x5afbb540e1ff255db40e437550d02c16227d26d222aa8bd239e1728b61c051c2\",\"license\":\"BSD-3-Clause-Clear\"},\"@openzeppelin/contracts/interfaces/IERC5267.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\",\"keccak256\":\"0x92aa1df62dc3d33f1656d63bede0923e0df0b706ad4137c8b10b0a8fe549fd92\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ShortStrings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\n\\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\\n// | length  | 0x                                                              BB |\\ntype ShortString is bytes32;\\n\\n/**\\n * @dev This library provides functions to convert short memory strings\\n * into a `ShortString` type that can be used as an immutable variable.\\n *\\n * Strings of arbitrary length can be optimized using this library if\\n * they are short enough (up to 31 bytes) by packing them with their\\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\\n * fallback mechanism can be used for every other case.\\n *\\n * Usage example:\\n *\\n * ```solidity\\n * contract Named {\\n *     using ShortStrings for *;\\n *\\n *     ShortString private immutable _name;\\n *     string private _nameFallback;\\n *\\n *     constructor(string memory contractName) {\\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\\n *     }\\n *\\n *     function name() external view returns (string memory) {\\n *         return _name.toStringWithFallback(_nameFallback);\\n *     }\\n * }\\n * ```\\n */\\nlibrary ShortStrings {\\n    // Used as an identifier for strings longer than 31 bytes.\\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\\n\\n    error StringTooLong(string str);\\n    error InvalidShortString();\\n\\n    /**\\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\\n     *\\n     * This will trigger a `StringTooLong` error is the input string is too long.\\n     */\\n    function toShortString(string memory str) internal pure returns (ShortString) {\\n        bytes memory bstr = bytes(str);\\n        if (bstr.length > 31) {\\n            revert StringTooLong(str);\\n        }\\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\\n    }\\n\\n    /**\\n     * @dev Decode a `ShortString` back to a \\\"normal\\\" string.\\n     */\\n    function toString(ShortString sstr) internal pure returns (string memory) {\\n        uint256 len = byteLength(sstr);\\n        // using `new string(len)` would work locally but is not memory safe.\\n        string memory str = new string(32);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(str, len)\\n            mstore(add(str, 0x20), sstr)\\n        }\\n        return str;\\n    }\\n\\n    /**\\n     * @dev Return the length of a `ShortString`.\\n     */\\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\\n        if (result > 31) {\\n            revert InvalidShortString();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\\n     */\\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\\n        if (bytes(value).length < 32) {\\n            return toShortString(value);\\n        } else {\\n            StorageSlot.getStringSlot(store).value = value;\\n            return ShortString.wrap(FALLBACK_SENTINEL);\\n        }\\n    }\\n\\n    /**\\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     */\\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return toString(value);\\n        } else {\\n            return store;\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\\n     * {setWithFallback}.\\n     *\\n     * WARNING: This will return the \\\"byte length\\\" of the string. This may not reflect the actual length in terms of\\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\\n     */\\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return byteLength(value);\\n        } else {\\n            return bytes(store).length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x18a7171df639a934592915a520ecb97c5bbc9675a1105607aac8a94e72bf62c6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x32ba59b4b7299237c8ba56319110989d7978a039faf754793064e967e5894418\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS\\n    }\\n\\n    /**\\n     * @dev The signature derives the `address(0)`.\\n     */\\n    error ECDSAInvalidSignature();\\n\\n    /**\\n     * @dev The signature has an invalid length.\\n     */\\n    error ECDSAInvalidSignatureLength(uint256 length);\\n\\n    /**\\n     * @dev The signature has an S value that is in the upper half order.\\n     */\\n    error ECDSAInvalidSignatureS(bytes32 s);\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\n     * and a bytes32 providing additional information about the error.\\n     *\\n     * If no error is returned, then the address can be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\n        unchecked {\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            return tryRecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError, bytes32) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\n        }\\n\\n        return (signer, RecoverError.NoError, bytes32(0));\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\n     */\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert ECDSAInvalidSignature();\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert ECDSAInvalidSignatureS(errorArg);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeed0a08b0b091f528356cbc7245891a4c748682d4f6a18055e8e6ca77d12a6cf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {MessageHashUtils} from \\\"./MessageHashUtils.sol\\\";\\nimport {ShortStrings, ShortString} from \\\"../ShortStrings.sol\\\";\\nimport {IERC5267} from \\\"../../interfaces/IERC5267.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\\n *\\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n */\\nabstract contract EIP712 is IERC5267 {\\n    using ShortStrings for *;\\n\\n    bytes32 private constant TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _cachedDomainSeparator;\\n    uint256 private immutable _cachedChainId;\\n    address private immutable _cachedThis;\\n\\n    bytes32 private immutable _hashedName;\\n    bytes32 private immutable _hashedVersion;\\n\\n    ShortString private immutable _name;\\n    ShortString private immutable _version;\\n    string private _nameFallback;\\n    string private _versionFallback;\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _name = name.toShortStringWithFallback(_nameFallback);\\n        _version = version.toShortStringWithFallback(_versionFallback);\\n        _hashedName = keccak256(bytes(name));\\n        _hashedVersion = keccak256(bytes(version));\\n\\n        _cachedChainId = block.chainid;\\n        _cachedDomainSeparator = _buildDomainSeparator();\\n        _cachedThis = address(this);\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\\n            return _cachedDomainSeparator;\\n        } else {\\n            return _buildDomainSeparator();\\n        }\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev See {IERC-5267}.\\n     */\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            _EIP712Name(),\\n            _EIP712Version(),\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n\\n    /**\\n     * @dev The name parameter for the EIP712 domain.\\n     *\\n     * NOTE: By default this function reads _name which is an immutable value.\\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _EIP712Name() internal view returns (string memory) {\\n        return _name.toStringWithFallback(_nameFallback);\\n    }\\n\\n    /**\\n     * @dev The version parameter for the EIP712 domain.\\n     *\\n     * NOTE: By default this function reads _version which is an immutable value.\\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _EIP712Version() internal view returns (string memory) {\\n        return _version.toStringWithFallback(_versionFallback);\\n    }\\n}\\n\",\"keccak256\":\"0x999f705a027ed6dc2d4e0df2cc4a509852c6bfd11de1c8161bf88832d0503fd0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Strings} from \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\\n *\\n * The library provides methods for generating a hash of a message that conforms to the\\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\\n * specifications.\\n */\\nlibrary MessageHashUtils {\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\\n     * keccak256, although any bytes32 value can be safely used because the final digest will\\n     * be re-hashed.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\") // 32 is the bytes-length of messageHash\\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `message` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\\n        return\\n            keccak256(bytes.concat(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", bytes(Strings.toString(message.length)), message));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x00` (data with intended validator).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `data` with `\\\"\\\\x19\\\\x00\\\"` and the intended\\n     * `validator` address. Then hashing the result.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(hex\\\"19_00\\\", validator, data));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\\n     *\\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\\n     * `\\\\x19\\\\x01` and hashing the result. It corresponds to the hash signed by the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"19_01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            digest := keccak256(ptr, 0x42)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xba333517a3add42cd35fe877656fc3dfcc9de53baa4f3aabbd6d12a92e4ea435\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72\",\"license\":\"MIT\"},\"contracts/FugaziPoolRegistryFacet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.24;\\n\\nimport \\\"./FugaziStorageLayout.sol\\\";\\n\\n// This facet will handle pool registry operations\\ncontract FugaziPoolRegistryFacet is FugaziStorageLayout {\\n    // create pool\\n    function createPool(address tokenX, address tokenY, inEuint32 calldata _initialReserves) external {\\n        /* transform the type:\\n        smallest 15 bits = initial reserve of tokenY\\n        next 15 bits = initial reserve of tokenX\\n        we ignore the rest\\n\\n        due to the formula of AMM, each token amount should satisfy the following condition:\\n        (max token in pool)^2 * 4 < 2^32 (or 2^64, 2^128, so on...)\\n\\n        For the derivation of the formula, please refer to jupyter notebook in repo\\n        */\\n        euint32 initialReserves = FHE.asEuint32(_initialReserves);\\n\\n        // adjust the input; we cannot create a pool with reserves more than the owner has\\n        euint32 availabeX = FHE.min(\\n            account[msg.sender].balanceOf[tokenX],\\n            FHE.shr(FHE.and(initialReserves, FHE.asEuint32(1073709056)), FHE.asEuint32(15)) // and(initialReserves, (2^30 - 1) - (2^15 - 1)) >> 15\\n        );\\n        euint32 availabeY = FHE.min(\\n            account[msg.sender].balanceOf[tokenY],\\n            FHE.and(initialReserves, FHE.asEuint32(32767)) // smallest 15 bits (32767 = 2 ** 15 - 1)\\n        );\\n\\n        // minimum reserves: at least 2048 of each token\\n        // This is for taking strictly positive amount of fee in both reserve tokens and LP tokens\\n        FHE.req(\\n            FHE.and(\\n                FHE.gt(availabeX, FHE.asEuint32(2048)), // X reserve should be at least 2048\\n                FHE.gt(availabeY, FHE.asEuint32(2048)) // Y reserve should be at least 2048\\n            )\\n        );\\n\\n        // deduct the token balance of msg.sender\\n        account[msg.sender].balanceOf[tokenX] = account[msg.sender].balanceOf[tokenX] - availabeX;\\n        account[msg.sender].balanceOf[tokenY] = account[msg.sender].balanceOf[tokenY] - availabeY;\\n\\n        // construct input\\n        poolCreationInputStruct memory poolCreationInput = poolCreationInputStruct({\\n            tokenX: tokenX,\\n            tokenY: tokenY,\\n            initialReserveX: availabeX,\\n            initialReserveY: availabeY\\n        });\\n\\n        // create pool - to avoid the stack too deep error we use a helper function\\n        _createPool(poolCreationInput);\\n    }\\n\\n    function _createPool(poolCreationInputStruct memory i) internal {\\n        // check if the input tokens are in right order\\n        if (i.tokenY <= i.tokenX) revert InvalidTokenOrder();\\n\\n        // check if pool already exists\\n        bytes32 poolId = getPoolId(i.tokenX, i.tokenY);\\n        if (poolId != bytes32(0)) {\\n            revert PoolAlreadyExists();\\n        }\\n\\n        // update pool id mapping\\n        poolIdMapping[i.tokenX][i.tokenY] = keccak256(abi.encodePacked(i.tokenX, i.tokenY));\\n        poolId = getPoolId(i.tokenX, i.tokenY);\\n\\n        // initialize pool\\n        poolStateStruct storage $ = poolState[poolId];\\n        _initializePool($, i);\\n\\n        // emit event\\n        emit PoolCreated(i.tokenX, i.tokenY, poolId);\\n    }\\n\\n    function _initializePool(poolStateStruct storage $, poolCreationInputStruct memory i) internal {\\n        // set token addresses\\n        $.tokenX = i.tokenX;\\n        $.tokenY = i.tokenY;\\n\\n        // set epoch & settlement time\\n        $.epoch = 0;\\n        $.lastSettlement = uint32(block.timestamp);\\n        $.settlementStep = 0;\\n\\n        // take half of fee and set protocol account balances\\n        $.protocolX = FHE.shr(i.initialReserveX, FHE.asEuint32(feeBitShifts + 1));\\n        $.protocolY = FHE.shr(i.initialReserveY, FHE.asEuint32(feeBitShifts + 1));\\n\\n        // set reserves\\n        $.reserveX = i.initialReserveX - $.protocolX;\\n        $.reserveY = i.initialReserveY - $.protocolY;\\n\\n        // mint LP token and take another half of fee\\n        $.lpTotalSupply = FHE.max($.reserveX, $.reserveY); // should be less than 2^15 too\\n        $.lpBalanceOf[address(this)] = FHE.shr($.lpTotalSupply, FHE.asEuint32(feeBitShifts + 1)); // this will be locked permanently\\n        $.lpBalanceOf[msg.sender] = $.lpTotalSupply - $.lpBalanceOf[address(this)];\\n    }\\n\\n    // get pool id\\n    function getPoolId(address tokenX, address tokenY) public view returns (bytes32) {\\n        return tokenX < tokenY ? poolIdMapping[tokenX][tokenY] : poolIdMapping[tokenY][tokenX];\\n    }\\n}\\n\",\"keccak256\":\"0x905236bc02b6de36940affb07ba93907d6ccb3ee0e61e0b6f8fb835099106440\",\"license\":\"UNLICENSED\"},\"contracts/FugaziStorageLayout.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.24;\\n\\nimport \\\"@fhenixprotocol/contracts/FHE.sol\\\";\\nimport {Permissioned, Permission} from \\\"@fhenixprotocol/contracts/access/Permissioned.sol\\\";\\n\\n// This will be used to store all the storage variables & will be inherited by all of the other contracts\\n// every library should be imported here\\ncontract FugaziStorageLayout is Permissioned {\\n    // import FHE library\\n    using FHE for euint32;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           Diamond                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // errors\\n    error noCorrespondingFacet();\\n    error notOwner();\\n\\n    // events\\n    event facetAdded(bytes4 selector, address facet);\\n\\n    // modifiers\\n    modifier onlyOwner() {\\n        if (msg.sender != owner) revert notOwner();\\n        _;\\n    }\\n\\n    // structs\\n    struct facetAndSelectorStruct {\\n        address facet;\\n        bytes4 selector;\\n    }\\n\\n    // storage variables\\n    address internal owner;\\n    mapping(bytes4 => address) internal selectorTofacet;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       Account Facet                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // errors\\n\\n    // events - we do not emit amount to keep the confidentiality\\n    event Deposit(address recipient, address token);\\n    event Withdraw(address recipient, address token);\\n\\n    // modifiers\\n\\n    // structs\\n    struct unclaimedOrderStruct {\\n        bytes32 poolId;\\n        uint32 epoch;\\n    }\\n\\n    struct accountStruct {\\n        mapping(address => euint32) balanceOf; // token address => balance\\n        unclaimedOrderStruct[] unclaimedOrders;\\n    }\\n\\n    // storage variables\\n    mapping(address => accountStruct) internal account;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    Pool Registry Facet                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // errors\\n    error InvalidTokenOrder();\\n    error PoolAlreadyExists();\\n    error BatchIsSettlement();\\n\\n    // events\\n    event PoolCreated(address tokenX, address tokenY, bytes32 poolId);\\n\\n    // modifiers\\n    modifier notInSettlement(bytes32 poolId) {\\n        if (poolState[poolId].settlementStep != 0) revert BatchIsSettlement();\\n        _;\\n    }\\n\\n    // structs\\n    struct poolCreationInputStruct {\\n        address tokenX;\\n        address tokenY;\\n        euint32 initialReserveX;\\n        euint32 initialReserveY;\\n    }\\n\\n    struct poolStateStruct {\\n        // pool info\\n        address tokenX;\\n        address tokenY;\\n        uint32 epoch;\\n        uint32 lastSettlement;\\n        // settlement step counter\\n        uint32 settlementStep;\\n        // pool reserves\\n        euint32 reserveX;\\n        euint32 reserveY;\\n        /*\\n        protocol account\\n        The protocol will trade against itself with randomized order.\\n        User can set the parameters of randomization and pay the fee for additional privacy.\\n        */\\n        euint32 protocolX;\\n        euint32 protocolY;\\n        // LP token shares\\n        euint32 lpTotalSupply;\\n        mapping(address => euint32) lpBalanceOf;\\n        // information of each batch\\n        mapping(uint32 => batchStruct) batch; // batchStruct is defined in the Pool Action Facet section\\n    }\\n\\n    // storage variables\\n    uint32 internal constant feeBitShifts = 10;\\n    mapping(address => mapping(address => bytes32)) internal poolIdMapping;\\n    mapping(bytes32 => poolStateStruct) internal poolState;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     Pool Action Facet                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // errors\\n    error PoolNotFound();\\n    error EpochNotEnded();\\n    error OrderAlreadyClaimed();\\n\\n    // events\\n    event orderSubmitted(bytes32 poolId, uint32 epoch);\\n    event epochSettled(bytes32 poolId, uint32 epoch);\\n\\n    // modifiers\\n    modifier onlyValidPool(bytes32 poolId) {\\n        if (poolState[poolId].tokenX == address(0)) revert PoolNotFound();\\n        _;\\n    }\\n\\n    // structs\\n    struct batchStruct {\\n        // mapping of each individual swap & mint order\\n        mapping(address => orderStruct) order;\\n        ////////////////////////////////////////////////\\n        //                                            //\\n        //      state right before the settlement     //\\n        //                                            //\\n        ////////////////////////////////////////////////\\n        // initial pool state\\n        euint32 reserveX0;\\n        euint32 reserveY0;\\n        // sum of swap orders\\n        euint32 swapX;\\n        euint32 swapY;\\n        // sum of mint orders\\n        euint32 mintX;\\n        euint32 mintY;\\n        ////////////////////////////////////////////////\\n        //                                            //\\n        //   intermidiate values used in settlement   //\\n        //                                            //\\n        ////////////////////////////////////////////////\\n        intermidiateValuesStruct intermidiateValues;\\n        ////////////////////////////////////////////////\\n        //                                            //\\n        //      state right after the settlement      //\\n        //                                            //\\n        ////////////////////////////////////////////////\\n        // final pool state\\n        euint32 reserveX1;\\n        euint32 reserveY1;\\n        // final output amounts\\n        euint32 outX;\\n        euint32 outY;\\n        // newly minted LP tokens\\n        euint32 lpIncrement;\\n    }\\n\\n    struct orderStruct {\\n        euint32 swapX;\\n        euint32 swapY;\\n        euint32 mintX;\\n        euint32 mintY;\\n        bool claimed;\\n    }\\n\\n    struct intermidiateValuesStruct {\\n        euint32 XForPricing;\\n        euint32 YForPricing;\\n    }\\n\\n    // storage variables\\n    uint32 internal epochTime = 1 minutes;\\n}\\n\",\"keccak256\":\"0xb5675b27ce3506e886bc505e1c6848a08ff56270833524599b73612da585b683\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x610160604052603c600760006101000a81548163ffffffff021916908363ffffffff1602179055503480156200003457600080fd5b506040518060400160405280601181526020017f4668656e6978205065726d697373696f6e0000000000000000000000000000008152506040518060400160405280600381526020017f312e300000000000000000000000000000000000000000000000000000000000815250620000b76000836200015760201b90919060201c565b6101208181525050620000d56001826200015760201b90919060201c565b6101408181525050818051906020012060e08181525050808051906020012061010081815250504660a0818152505062000114620001af60201b60201c565b608081815250503073ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff1681525050505062000807565b60006020835110156200017d5762000175836200020c60201b60201c565b9050620001a9565b826200018f836200027960201b60201c565b6000019081620001a09190620004fd565b5060ff60001b90505b92915050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60e051610100514630604051602001620001f195949392919062000655565b60405160208183030381529060405280519060200120905090565b600080829050601f815111156200025c57826040517f305a27a900000000000000000000000000000000000000000000000000000000815260040162000253919062000741565b60405180910390fd5b8051816200026a9062000797565b60001c1760001b915050919050565b6000819050919050565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600060028204905060018216806200030557607f821691505b6020821081036200031b576200031a620002bd565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302620003857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000346565b62000391868362000346565b95508019841693508086168417925050509392505050565b6000819050919050565b6000819050919050565b6000620003de620003d8620003d284620003a9565b620003b3565b620003a9565b9050919050565b6000819050919050565b620003fa83620003bd565b620004126200040982620003e5565b84845462000353565b825550505050565b600090565b620004296200041a565b62000436818484620003ef565b505050565b5b818110156200045e57620004526000826200041f565b6001810190506200043c565b5050565b601f821115620004ad57620004778162000321565b620004828462000336565b8101602085101562000492578190505b620004aa620004a18562000336565b8301826200043b565b50505b505050565b600082821c905092915050565b6000620004d260001984600802620004b2565b1980831691505092915050565b6000620004ed8383620004bf565b9150826002028217905092915050565b620005088262000283565b67ffffffffffffffff8111156200052457620005236200028e565b5b620005308254620002ec565b6200053d82828562000462565b600060209050601f83116001811462000575576000841562000560578287015190505b6200056c8582620004df565b865550620005dc565b601f198416620005858662000321565b60005b82811015620005af5784890151825560018201915060208501945060208101905062000588565b86831015620005cf5784890151620005cb601f891682620004bf565b8355505b6001600288020188555050505b505050505050565b6000819050919050565b620005f981620005e4565b82525050565b6200060a81620003a9565b82525050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006200063d8262000610565b9050919050565b6200064f8162000630565b82525050565b600060a0820190506200066c6000830188620005ee565b6200067b6020830187620005ee565b6200068a6040830186620005ee565b620006996060830185620005ff565b620006a8608083018462000644565b9695505050505050565b600082825260208201905092915050565b60005b83811015620006e3578082015181840152602081019050620006c6565b60008484015250505050565b6000601f19601f8301169050919050565b60006200070d8262000283565b620007198185620006b2565b93506200072b818560208601620006c3565b6200073681620006ef565b840191505092915050565b600060208201905081810360008301526200075d818462000700565b905092915050565b600081519050919050565b6000819050602082019050919050565b60006200078e8251620005e4565b80915050919050565b6000620007a48262000765565b82620007b08462000770565b9050620007bd8162000780565b925060208210156200080057620007fb7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8360200360080262000346565b831692505b5050919050565b60805160a05160c05160e051610100516101205161014051611cf4620008536000396000610c4301526000610c0801526000505060005050600050506000505060005050611cf46000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80632ef61c2114610046578063467276391461007657806384b0196e14610092575b600080fd5b610060600480360381019061005b9190611487565b6100b6565b60405161006d91906114e0565b60405180910390f35b610090600480360381019061008b919061151f565b6101f3565b005b61009a610610565b6040516100ad979695949392919061173f565b60405180910390f35b60008173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161061016d57600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546101eb565b600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020545b905092915050565b6000610207826102029061195a565b6106ba565b905060006102bb600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546102b66102a7856102a2633fff80006106d0565b6106e4565b6102b1600f6106d0565b61075d565b6107d6565b9050600061035b600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461035685610351617fff6106d0565b6106e4565b6107d6565b9050610395610390610377846103726108006106d0565b61084f565b61038b846103866108006106d0565b61084f565b6108c8565b610941565b61041e600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054836109f6565b600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555061052a600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054826109f6565b600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550600060405180608001604052808873ffffffffffffffffffffffffffffffffffffffff1681526020018773ffffffffffffffffffffffffffffffffffffffff16815260200184815260200183815250905061060781610a0a565b50505050505050565b600060608060008060006060610624610bff565b61062c610c3a565b46306000801b600067ffffffffffffffff81111561064d5761064c6117c8565b5b60405190808252806020026020018201604052801561067b5781602001602082028036833780820191505090505b507f0f00000000000000000000000000000000000000000000000000000000000000959493929190965096509650965096509650965090919293949596565b60006106c98260000151610c75565b9050919050565b60006106dd826002610c89565b9050919050565b60006106ef83610d2b565b610700576106fd60006106d0565b92505b61070982610d2b565b61071a5761071760006106d0565b91505b60008390506000839050600061074f60028484608073ffffffffffffffffffffffffffffffffffffffff1663ae104cfd610d38565b905080935050505092915050565b600061076883610d2b565b6107795761077660006106d0565b92505b61078282610d2b565b6107935761079060006106d0565b91505b6000839050600083905060006107c860028484608073ffffffffffffffffffffffffffffffffffffffff16639944d12d610d38565b905080935050505092915050565b60006107e183610d2b565b6107f2576107ef60006106d0565b92505b6107fb82610d2b565b61080c5761080960006106d0565b91505b60008390506000839050600061084160028484608073ffffffffffffffffffffffffffffffffffffffff16635211c679610d38565b905080935050505092915050565b600061085a83610d2b565b61086b5761086860006106d0565b92505b61087482610d2b565b6108855761088260006106d0565b91505b6000839050600083905060006108ba60028484608073ffffffffffffffffffffffffffffffffffffffff1663874b1c10610d38565b905080935050505092915050565b60006108d383610dcc565b6108e4576108e16000610dd9565b92505b6108ed82610dcc565b6108fe576108fb6000610dd9565b91505b600083905060008390506000610933600d8484608073ffffffffffffffffffffffffffffffffffffffff1663ae104cfd610d38565b905080935050505092915050565b61094a81610dcc565b61095b576109586000610dd9565b90505b6000819050600061096b82610ded565b9050608073ffffffffffffffffffffffffffffffffffffffff16637d23f1db600d836040518363ffffffff1660e01b81526004016109aa9291906119de565b600060405180830381865afa1580156109c7573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906109f09190611a7e565b50505050565b6000610a028383610e4a565b905092915050565b806000015173ffffffffffffffffffffffffffffffffffffffff16816020015173ffffffffffffffffffffffffffffffffffffffff1611610a77576040517f3f06bf8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610a8b826000015183602001516100b6565b90506000801b8114610ac9576040517f0311932200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81600001518260200151604051602001610ae4929190611b0f565b6040516020818303038152906040528051906020012060056000846000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000846020015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610b94826000015183602001516100b6565b90506000600660008381526020019081526020016000209050610bb78184610ec3565b7fec5dc6309c83a50f60f4a1fae9422b2c406da78c579b9b12b92d033db37c71948360000151846020015184604051610bf293929190611b3b565b60405180910390a1505050565b6060610c3560007f000000000000000000000000000000000000000000000000000000000000000061117290919063ffffffff16565b905090565b6060610c7060017f000000000000000000000000000000000000000000000000000000000000000061117290919063ffffffff16565b905090565b6000610c82826002611222565b9050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c4610cb386610ded565b856040518363ffffffff1660e01b8152600401610cd1929190611b72565b600060405180830381865afa158015610cee573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610d179190611a7e565b9050610d22816112bc565b91505092915050565b6000808214159050919050565b60006060838388610d4889610ded565b610d5189610ded565b6040518463ffffffff1660e01b8152600401610d6f93929190611ba2565b600060405180830381865afa158015610d8c573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610db59190611a7e565b9050610dc0816112ca565b91505095945050505050565b6000808214159050919050565b6000610de682600d610c89565b9050919050565b6060602067ffffffffffffffff811115610e0a57610e096117c8565b5b6040519080825280601f01601f191660200182016040528015610e3c5781602001600182028036833780820191505090505b509050816020820152919050565b6000610e5583610d2b565b610e6657610e6360006106d0565b92505b610e6f82610d2b565b610e8057610e7d60006106d0565b91505b600083905060008390506000610eb560028484608073ffffffffffffffffffffffffffffffffffffffff1663cc2cbeff610d38565b905080935050505092915050565b80600001518260000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080602001518260010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060008260010160146101000a81548163ffffffff021916908363ffffffff160217905550428260010160186101000a81548163ffffffff021916908363ffffffff160217905550600082600101601c6101000a81548163ffffffff021916908363ffffffff160217905550610fe58160400151610fe06001600a610fd59190611c26565b63ffffffff166106d0565b61075d565b826004018190555061101681606001516110116001600a6110069190611c26565b63ffffffff166106d0565b61075d565b8260050181905550611030816040015183600401546109f6565b826002018190555061104a816060015183600501546109f6565b8260030181905550611064826002015483600301546112d8565b826006018190555061109582600601546110906001600a6110859190611c26565b63ffffffff166106d0565b61075d565b8260070160003073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555061112982600601548360070160003073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546109f6565b8260070160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505050565b606060ff60001b831461118f5761118883611351565b905061121c565b81805461119b90611c8d565b80601f01602080910402602001604051908101604052809291908181526020018280546111c790611c8d565b80156112145780601f106111e957610100808354040283529160200191611214565b820191906000526020600020905b8154815290600101906020018083116111f757829003601f168201915b505050505090505b92915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16635fa55ca784866040518363ffffffff1660e01b81526004016112629291906119de565b600060405180830381865afa15801561127f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906112a89190611a7e565b90506112b3816112bc565b91505092915050565b600060208201519050919050565b600060208201519050919050565b60006112e383610d2b565b6112f4576112f160006106d0565b92505b6112fd82610d2b565b61130e5761130b60006106d0565b91505b60008390506000839050600061134360028484608073ffffffffffffffffffffffffffffffffffffffff16630b80518e610d38565b905080935050505092915050565b6060600061135e836113c5565b90506000602067ffffffffffffffff81111561137d5761137c6117c8565b5b6040519080825280601f01601f1916602001820160405280156113af5781602001600182028036833780820191505090505b5090508181528360208201528092505050919050565b60008060ff8360001c169050601f81111561140c576040517fb3512b0c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80915050919050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061145482611429565b9050919050565b61146481611449565b811461146f57600080fd5b50565b6000813590506114818161145b565b92915050565b6000806040838503121561149e5761149d61141f565b5b60006114ac85828601611472565b92505060206114bd85828601611472565b9150509250929050565b6000819050919050565b6114da816114c7565b82525050565b60006020820190506114f560008301846114d1565b92915050565b600080fd5b600060208284031215611516576115156114fb565b5b81905092915050565b6000806000606084860312156115385761153761141f565b5b600061154686828701611472565b935050602061155786828701611472565b925050604084013567ffffffffffffffff81111561157857611577611424565b5b61158486828701611500565b9150509250925092565b60007fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b6115c38161158e565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b838110156116035780820151818401526020810190506115e8565b60008484015250505050565b6000601f19601f8301169050919050565b600061162b826115c9565b61163581856115d4565b93506116458185602086016115e5565b61164e8161160f565b840191505092915050565b6000819050919050565b61166c81611659565b82525050565b61167b81611449565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6116b681611659565b82525050565b60006116c883836116ad565b60208301905092915050565b6000602082019050919050565b60006116ec82611681565b6116f6818561168c565b93506117018361169d565b8060005b8381101561173257815161171988826116bc565b9750611724836116d4565b925050600181019050611705565b5085935050505092915050565b600060e082019050611754600083018a6115ba565b81810360208301526117668189611620565b9050818103604083015261177a8188611620565b90506117896060830187611663565b6117966080830186611672565b6117a360a08301856114d1565b81810360c08301526117b581846116e1565b905098975050505050505050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6118008261160f565b810181811067ffffffffffffffff8211171561181f5761181e6117c8565b5b80604052505050565b6000611832611415565b905061183e82826117f7565b919050565b600080fd5b600080fd5b600080fd5b600067ffffffffffffffff82111561186d5761186c6117c8565b5b6118768261160f565b9050602081019050919050565b82818337600083830152505050565b60006118a56118a084611852565b611828565b9050828152602081018484840111156118c1576118c061184d565b5b6118cc848285611883565b509392505050565b600082601f8301126118e9576118e8611848565b5b81356118f9848260208601611892565b91505092915050565b600060208284031215611918576119176117c3565b5b6119226020611828565b9050600082013567ffffffffffffffff81111561194257611941611843565b5b61194e848285016118d4565b60008301525092915050565b60006119663683611902565b9050919050565b600060ff82169050919050565b6119838161196d565b82525050565b600081519050919050565b600082825260208201905092915050565b60006119b082611989565b6119ba8185611994565b93506119ca8185602086016115e5565b6119d38161160f565b840191505092915050565b60006040820190506119f3600083018561197a565b8181036020830152611a0581846119a5565b90509392505050565b6000611a21611a1c84611852565b611828565b905082815260208101848484011115611a3d57611a3c61184d565b5b611a488482856115e5565b509392505050565b600082601f830112611a6557611a64611848565b5b8151611a75848260208601611a0e565b91505092915050565b600060208284031215611a9457611a9361141f565b5b600082015167ffffffffffffffff811115611ab257611ab1611424565b5b611abe84828501611a50565b91505092915050565b60008160601b9050919050565b6000611adf82611ac7565b9050919050565b6000611af182611ad4565b9050919050565b611b09611b0482611449565b611ae6565b82525050565b6000611b1b8285611af8565b601482019150611b2b8284611af8565b6014820191508190509392505050565b6000606082019050611b506000830186611672565b611b5d6020830185611672565b611b6a60408301846114d1565b949350505050565b60006040820190508181036000830152611b8c81856119a5565b9050611b9b602083018461197a565b9392505050565b6000606082019050611bb7600083018661197a565b8181036020830152611bc981856119a5565b90508181036040830152611bdd81846119a5565b9050949350505050565b600063ffffffff82169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611c3182611be7565b9150611c3c83611be7565b9250828201905063ffffffff811115611c5857611c57611bf7565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611ca557607f821691505b602082108103611cb857611cb7611c5e565b5b5091905056fea264697066735822122019b0d677df3076f4050a409fb80a70131cd3f5f6b2b0a22d474febbdb781144f64736f6c63430008180033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80632ef61c2114610046578063467276391461007657806384b0196e14610092575b600080fd5b610060600480360381019061005b9190611487565b6100b6565b60405161006d91906114e0565b60405180910390f35b610090600480360381019061008b919061151f565b6101f3565b005b61009a610610565b6040516100ad979695949392919061173f565b60405180910390f35b60008173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161061016d57600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546101eb565b600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020545b905092915050565b6000610207826102029061195a565b6106ba565b905060006102bb600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546102b66102a7856102a2633fff80006106d0565b6106e4565b6102b1600f6106d0565b61075d565b6107d6565b9050600061035b600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461035685610351617fff6106d0565b6106e4565b6107d6565b9050610395610390610377846103726108006106d0565b61084f565b61038b846103866108006106d0565b61084f565b6108c8565b610941565b61041e600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054836109f6565b600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555061052a600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054826109f6565b600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550600060405180608001604052808873ffffffffffffffffffffffffffffffffffffffff1681526020018773ffffffffffffffffffffffffffffffffffffffff16815260200184815260200183815250905061060781610a0a565b50505050505050565b600060608060008060006060610624610bff565b61062c610c3a565b46306000801b600067ffffffffffffffff81111561064d5761064c6117c8565b5b60405190808252806020026020018201604052801561067b5781602001602082028036833780820191505090505b507f0f00000000000000000000000000000000000000000000000000000000000000959493929190965096509650965096509650965090919293949596565b60006106c98260000151610c75565b9050919050565b60006106dd826002610c89565b9050919050565b60006106ef83610d2b565b610700576106fd60006106d0565b92505b61070982610d2b565b61071a5761071760006106d0565b91505b60008390506000839050600061074f60028484608073ffffffffffffffffffffffffffffffffffffffff1663ae104cfd610d38565b905080935050505092915050565b600061076883610d2b565b6107795761077660006106d0565b92505b61078282610d2b565b6107935761079060006106d0565b91505b6000839050600083905060006107c860028484608073ffffffffffffffffffffffffffffffffffffffff16639944d12d610d38565b905080935050505092915050565b60006107e183610d2b565b6107f2576107ef60006106d0565b92505b6107fb82610d2b565b61080c5761080960006106d0565b91505b60008390506000839050600061084160028484608073ffffffffffffffffffffffffffffffffffffffff16635211c679610d38565b905080935050505092915050565b600061085a83610d2b565b61086b5761086860006106d0565b92505b61087482610d2b565b6108855761088260006106d0565b91505b6000839050600083905060006108ba60028484608073ffffffffffffffffffffffffffffffffffffffff1663874b1c10610d38565b905080935050505092915050565b60006108d383610dcc565b6108e4576108e16000610dd9565b92505b6108ed82610dcc565b6108fe576108fb6000610dd9565b91505b600083905060008390506000610933600d8484608073ffffffffffffffffffffffffffffffffffffffff1663ae104cfd610d38565b905080935050505092915050565b61094a81610dcc565b61095b576109586000610dd9565b90505b6000819050600061096b82610ded565b9050608073ffffffffffffffffffffffffffffffffffffffff16637d23f1db600d836040518363ffffffff1660e01b81526004016109aa9291906119de565b600060405180830381865afa1580156109c7573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906109f09190611a7e565b50505050565b6000610a028383610e4a565b905092915050565b806000015173ffffffffffffffffffffffffffffffffffffffff16816020015173ffffffffffffffffffffffffffffffffffffffff1611610a77576040517f3f06bf8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610a8b826000015183602001516100b6565b90506000801b8114610ac9576040517f0311932200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81600001518260200151604051602001610ae4929190611b0f565b6040516020818303038152906040528051906020012060056000846000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000846020015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610b94826000015183602001516100b6565b90506000600660008381526020019081526020016000209050610bb78184610ec3565b7fec5dc6309c83a50f60f4a1fae9422b2c406da78c579b9b12b92d033db37c71948360000151846020015184604051610bf293929190611b3b565b60405180910390a1505050565b6060610c3560007f000000000000000000000000000000000000000000000000000000000000000061117290919063ffffffff16565b905090565b6060610c7060017f000000000000000000000000000000000000000000000000000000000000000061117290919063ffffffff16565b905090565b6000610c82826002611222565b9050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c4610cb386610ded565b856040518363ffffffff1660e01b8152600401610cd1929190611b72565b600060405180830381865afa158015610cee573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610d179190611a7e565b9050610d22816112bc565b91505092915050565b6000808214159050919050565b60006060838388610d4889610ded565b610d5189610ded565b6040518463ffffffff1660e01b8152600401610d6f93929190611ba2565b600060405180830381865afa158015610d8c573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610db59190611a7e565b9050610dc0816112ca565b91505095945050505050565b6000808214159050919050565b6000610de682600d610c89565b9050919050565b6060602067ffffffffffffffff811115610e0a57610e096117c8565b5b6040519080825280601f01601f191660200182016040528015610e3c5781602001600182028036833780820191505090505b509050816020820152919050565b6000610e5583610d2b565b610e6657610e6360006106d0565b92505b610e6f82610d2b565b610e8057610e7d60006106d0565b91505b600083905060008390506000610eb560028484608073ffffffffffffffffffffffffffffffffffffffff1663cc2cbeff610d38565b905080935050505092915050565b80600001518260000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080602001518260010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060008260010160146101000a81548163ffffffff021916908363ffffffff160217905550428260010160186101000a81548163ffffffff021916908363ffffffff160217905550600082600101601c6101000a81548163ffffffff021916908363ffffffff160217905550610fe58160400151610fe06001600a610fd59190611c26565b63ffffffff166106d0565b61075d565b826004018190555061101681606001516110116001600a6110069190611c26565b63ffffffff166106d0565b61075d565b8260050181905550611030816040015183600401546109f6565b826002018190555061104a816060015183600501546109f6565b8260030181905550611064826002015483600301546112d8565b826006018190555061109582600601546110906001600a6110859190611c26565b63ffffffff166106d0565b61075d565b8260070160003073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555061112982600601548360070160003073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546109f6565b8260070160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505050565b606060ff60001b831461118f5761118883611351565b905061121c565b81805461119b90611c8d565b80601f01602080910402602001604051908101604052809291908181526020018280546111c790611c8d565b80156112145780601f106111e957610100808354040283529160200191611214565b820191906000526020600020905b8154815290600101906020018083116111f757829003601f168201915b505050505090505b92915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16635fa55ca784866040518363ffffffff1660e01b81526004016112629291906119de565b600060405180830381865afa15801561127f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906112a89190611a7e565b90506112b3816112bc565b91505092915050565b600060208201519050919050565b600060208201519050919050565b60006112e383610d2b565b6112f4576112f160006106d0565b92505b6112fd82610d2b565b61130e5761130b60006106d0565b91505b60008390506000839050600061134360028484608073ffffffffffffffffffffffffffffffffffffffff16630b80518e610d38565b905080935050505092915050565b6060600061135e836113c5565b90506000602067ffffffffffffffff81111561137d5761137c6117c8565b5b6040519080825280601f01601f1916602001820160405280156113af5781602001600182028036833780820191505090505b5090508181528360208201528092505050919050565b60008060ff8360001c169050601f81111561140c576040517fb3512b0c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80915050919050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061145482611429565b9050919050565b61146481611449565b811461146f57600080fd5b50565b6000813590506114818161145b565b92915050565b6000806040838503121561149e5761149d61141f565b5b60006114ac85828601611472565b92505060206114bd85828601611472565b9150509250929050565b6000819050919050565b6114da816114c7565b82525050565b60006020820190506114f560008301846114d1565b92915050565b600080fd5b600060208284031215611516576115156114fb565b5b81905092915050565b6000806000606084860312156115385761153761141f565b5b600061154686828701611472565b935050602061155786828701611472565b925050604084013567ffffffffffffffff81111561157857611577611424565b5b61158486828701611500565b9150509250925092565b60007fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b6115c38161158e565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b838110156116035780820151818401526020810190506115e8565b60008484015250505050565b6000601f19601f8301169050919050565b600061162b826115c9565b61163581856115d4565b93506116458185602086016115e5565b61164e8161160f565b840191505092915050565b6000819050919050565b61166c81611659565b82525050565b61167b81611449565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6116b681611659565b82525050565b60006116c883836116ad565b60208301905092915050565b6000602082019050919050565b60006116ec82611681565b6116f6818561168c565b93506117018361169d565b8060005b8381101561173257815161171988826116bc565b9750611724836116d4565b925050600181019050611705565b5085935050505092915050565b600060e082019050611754600083018a6115ba565b81810360208301526117668189611620565b9050818103604083015261177a8188611620565b90506117896060830187611663565b6117966080830186611672565b6117a360a08301856114d1565b81810360c08301526117b581846116e1565b905098975050505050505050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6118008261160f565b810181811067ffffffffffffffff8211171561181f5761181e6117c8565b5b80604052505050565b6000611832611415565b905061183e82826117f7565b919050565b600080fd5b600080fd5b600080fd5b600067ffffffffffffffff82111561186d5761186c6117c8565b5b6118768261160f565b9050602081019050919050565b82818337600083830152505050565b60006118a56118a084611852565b611828565b9050828152602081018484840111156118c1576118c061184d565b5b6118cc848285611883565b509392505050565b600082601f8301126118e9576118e8611848565b5b81356118f9848260208601611892565b91505092915050565b600060208284031215611918576119176117c3565b5b6119226020611828565b9050600082013567ffffffffffffffff81111561194257611941611843565b5b61194e848285016118d4565b60008301525092915050565b60006119663683611902565b9050919050565b600060ff82169050919050565b6119838161196d565b82525050565b600081519050919050565b600082825260208201905092915050565b60006119b082611989565b6119ba8185611994565b93506119ca8185602086016115e5565b6119d38161160f565b840191505092915050565b60006040820190506119f3600083018561197a565b8181036020830152611a0581846119a5565b90509392505050565b6000611a21611a1c84611852565b611828565b905082815260208101848484011115611a3d57611a3c61184d565b5b611a488482856115e5565b509392505050565b600082601f830112611a6557611a64611848565b5b8151611a75848260208601611a0e565b91505092915050565b600060208284031215611a9457611a9361141f565b5b600082015167ffffffffffffffff811115611ab257611ab1611424565b5b611abe84828501611a50565b91505092915050565b60008160601b9050919050565b6000611adf82611ac7565b9050919050565b6000611af182611ad4565b9050919050565b611b09611b0482611449565b611ae6565b82525050565b6000611b1b8285611af8565b601482019150611b2b8284611af8565b6014820191508190509392505050565b6000606082019050611b506000830186611672565b611b5d6020830185611672565b611b6a60408301846114d1565b949350505050565b60006040820190508181036000830152611b8c81856119a5565b9050611b9b602083018461197a565b9392505050565b6000606082019050611bb7600083018661197a565b8181036020830152611bc981856119a5565b90508181036040830152611bdd81846119a5565b9050949350505050565b600063ffffffff82169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611c3182611be7565b9150611c3c83611be7565b9250828201905063ffffffff811115611c5857611c57611bf7565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611ca557607f821691505b602082108103611cb857611cb7611c5e565b5b5091905056fea264697066735822122019b0d677df3076f4050a409fb80a70131cd3f5f6b2b0a22d474febbdb781144f64736f6c63430008180033",
  "devdoc": {
    "events": {
      "EIP712DomainChanged()": {
        "details": "MAY be emitted to signal that the domain could have changed."
      }
    },
    "kind": "dev",
    "methods": {
      "eip712Domain()": {
        "details": "See {IERC-5267}."
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "SignerNotMessageSender()": [
        {
          "notice": "Emitted when the signer is not the message sender"
        }
      ],
      "SignerNotOwner()": [
        {
          "notice": "Emitted when the signer is not the specified owner"
        }
      ]
    },
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 16568,
        "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
        "label": "_nameFallback",
        "offset": 0,
        "slot": "0",
        "type": "t_string_storage"
      },
      {
        "astId": 16570,
        "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
        "label": "_versionFallback",
        "offset": 0,
        "slot": "1",
        "type": "t_string_storage"
      },
      {
        "astId": 19991,
        "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
        "label": "owner",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 19995,
        "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
        "label": "selectorTofacet",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_bytes4,t_address)"
      },
      {
        "astId": 20027,
        "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
        "label": "account",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_struct(accountStruct)20022_storage)"
      },
      {
        "astId": 20113,
        "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
        "label": "poolIdMapping",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bytes32))"
      },
      {
        "astId": 20118,
        "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
        "label": "poolState",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_bytes32,t_struct(poolStateStruct)20104_storage)"
      },
      {
        "astId": 20222,
        "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
        "label": "epochTime",
        "offset": 0,
        "slot": "7",
        "type": "t_uint32"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(unclaimedOrderStruct)20012_storage)dyn_storage": {
        "base": "t_struct(unclaimedOrderStruct)20012_storage",
        "encoding": "dynamic_array",
        "label": "struct FugaziStorageLayout.unclaimedOrderStruct[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_mapping(t_address,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bytes32))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bytes32))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bytes32)"
      },
      "t_mapping(t_address,t_struct(accountStruct)20022_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct FugaziStorageLayout.accountStruct)",
        "numberOfBytes": "32",
        "value": "t_struct(accountStruct)20022_storage"
      },
      "t_mapping(t_address,t_struct(orderStruct)20212_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct FugaziStorageLayout.orderStruct)",
        "numberOfBytes": "32",
        "value": "t_struct(orderStruct)20212_storage"
      },
      "t_mapping(t_address,t_userDefinedValueType(euint32)12)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => euint32)",
        "numberOfBytes": "32",
        "value": "t_userDefinedValueType(euint32)12"
      },
      "t_mapping(t_bytes32,t_struct(poolStateStruct)20104_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct FugaziStorageLayout.poolStateStruct)",
        "numberOfBytes": "32",
        "value": "t_struct(poolStateStruct)20104_storage"
      },
      "t_mapping(t_bytes4,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint32,t_struct(batchStruct)20197_storage)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => struct FugaziStorageLayout.batchStruct)",
        "numberOfBytes": "32",
        "value": "t_struct(batchStruct)20197_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(accountStruct)20022_storage": {
        "encoding": "inplace",
        "label": "struct FugaziStorageLayout.accountStruct",
        "members": [
          {
            "astId": 20017,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "balanceOf",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_userDefinedValueType(euint32)12)"
          },
          {
            "astId": 20021,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "unclaimedOrders",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_struct(unclaimedOrderStruct)20012_storage)dyn_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(batchStruct)20197_storage": {
        "encoding": "inplace",
        "label": "struct FugaziStorageLayout.batchStruct",
        "members": [
          {
            "astId": 20160,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "order",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_struct(orderStruct)20212_storage)"
          },
          {
            "astId": 20163,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "reserveX0",
            "offset": 0,
            "slot": "1",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20166,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "reserveY0",
            "offset": 0,
            "slot": "2",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20169,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "swapX",
            "offset": 0,
            "slot": "3",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20172,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "swapY",
            "offset": 0,
            "slot": "4",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20175,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "mintX",
            "offset": 0,
            "slot": "5",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20178,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "mintY",
            "offset": 0,
            "slot": "6",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20181,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "intermidiateValues",
            "offset": 0,
            "slot": "7",
            "type": "t_struct(intermidiateValuesStruct)20219_storage"
          },
          {
            "astId": 20184,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "reserveX1",
            "offset": 0,
            "slot": "9",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20187,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "reserveY1",
            "offset": 0,
            "slot": "10",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20190,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "outX",
            "offset": 0,
            "slot": "11",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20193,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "outY",
            "offset": 0,
            "slot": "12",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20196,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "lpIncrement",
            "offset": 0,
            "slot": "13",
            "type": "t_userDefinedValueType(euint32)12"
          }
        ],
        "numberOfBytes": "448"
      },
      "t_struct(intermidiateValuesStruct)20219_storage": {
        "encoding": "inplace",
        "label": "struct FugaziStorageLayout.intermidiateValuesStruct",
        "members": [
          {
            "astId": 20215,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "XForPricing",
            "offset": 0,
            "slot": "0",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20218,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "YForPricing",
            "offset": 0,
            "slot": "1",
            "type": "t_userDefinedValueType(euint32)12"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(orderStruct)20212_storage": {
        "encoding": "inplace",
        "label": "struct FugaziStorageLayout.orderStruct",
        "members": [
          {
            "astId": 20200,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "swapX",
            "offset": 0,
            "slot": "0",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20203,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "swapY",
            "offset": 0,
            "slot": "1",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20206,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "mintX",
            "offset": 0,
            "slot": "2",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20209,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "mintY",
            "offset": 0,
            "slot": "3",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20211,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "claimed",
            "offset": 0,
            "slot": "4",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(poolStateStruct)20104_storage": {
        "encoding": "inplace",
        "label": "struct FugaziStorageLayout.poolStateStruct",
        "members": [
          {
            "astId": 20070,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "tokenX",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 20072,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "tokenY",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 20074,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "epoch",
            "offset": 20,
            "slot": "1",
            "type": "t_uint32"
          },
          {
            "astId": 20076,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "lastSettlement",
            "offset": 24,
            "slot": "1",
            "type": "t_uint32"
          },
          {
            "astId": 20078,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "settlementStep",
            "offset": 28,
            "slot": "1",
            "type": "t_uint32"
          },
          {
            "astId": 20081,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "reserveX",
            "offset": 0,
            "slot": "2",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20084,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "reserveY",
            "offset": 0,
            "slot": "3",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20087,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "protocolX",
            "offset": 0,
            "slot": "4",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20090,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "protocolY",
            "offset": 0,
            "slot": "5",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20093,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "lpTotalSupply",
            "offset": 0,
            "slot": "6",
            "type": "t_userDefinedValueType(euint32)12"
          },
          {
            "astId": 20098,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "lpBalanceOf",
            "offset": 0,
            "slot": "7",
            "type": "t_mapping(t_address,t_userDefinedValueType(euint32)12)"
          },
          {
            "astId": 20103,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "batch",
            "offset": 0,
            "slot": "8",
            "type": "t_mapping(t_uint32,t_struct(batchStruct)20197_storage)"
          }
        ],
        "numberOfBytes": "288"
      },
      "t_struct(unclaimedOrderStruct)20012_storage": {
        "encoding": "inplace",
        "label": "struct FugaziStorageLayout.unclaimedOrderStruct",
        "members": [
          {
            "astId": 20009,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "poolId",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 20011,
            "contract": "contracts/FugaziPoolRegistryFacet.sol:FugaziPoolRegistryFacet",
            "label": "epoch",
            "offset": 0,
            "slot": "1",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_userDefinedValueType(euint32)12": {
        "encoding": "inplace",
        "label": "euint32",
        "numberOfBytes": "32"
      }
    }
  }
}